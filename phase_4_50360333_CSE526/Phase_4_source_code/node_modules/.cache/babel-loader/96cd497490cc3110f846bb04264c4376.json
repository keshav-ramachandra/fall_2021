{"ast":null,"code":"import { createSlice, nanoid, createAsyncThunk } from '@reduxjs/toolkit'; //import controller from '../controller'\n\nimport web3 from './../web3';\nimport { controller, tcontroller } from '../controller';\nimport { store } from '../../app/store';\nexport const getCurrentOrg = createAsyncThunk('Org/getCurrentOrg', async () => {\n  const acts = await web3.eth.getAccounts();\n  return {\n    currentOrg: acts[0]\n  };\n});\nexport const updateStats = createAsyncThunk('Org/updateStats', async data => {\n  let act = await web3.eth.getAccounts();\n  let balance = await tcontroller.methods.balanceOf(act[0]).call(); //let own = await store.getState().owner\n  //console.log(\"ownnene\", own)\n\n  let naccess = await controller.methods.doesUserHasNormalAccess(localStorage.getItem(\"owner\")).call({\n    from: act[0]\n  });\n  let paccess = await controller.methods.doesUserHasPremiumAccess(localStorage.getItem(\"owner\")).call({\n    from: act[0]\n  });\n\n  if (naccess == true) {\n    naccess = 'Yes';\n  } else {\n    naccess = 'No';\n  }\n\n  if (paccess == true) {\n    paccess = 'Yes';\n  } else {\n    paccess = 'No';\n  }\n\n  return {\n    currentOrg: act[0],\n    balance: balance,\n    paccess: paccess,\n    naccess: naccess\n  };\n});\nexport const registerAsOrganization = createAsyncThunk('Org/registerAsOrganizaton', async data => {\n  let act = await web3.eth.getAccounts();\n  await controller.methods.registerAsOrganization(data.name, parseInt(data.normalSubFee), parseInt(data.premiumSubFee)).send({\n    from: act[0]\n  });\n  return {\n    premiumSubFee: data.premiumSubFee,\n    normalSubFee: data.normalSubFee,\n    name: data.name,\n    owner: act[0]\n  };\n});\nexport const purchaseTokens = createAsyncThunk('Org/purchaseTokens', async data => {\n  let act = await web3.eth.getAccounts();\n  await controller.methods.purchaseTokens().send({\n    from: act[0],\n    value: data.value\n  });\n  let balance = await tcontroller.methods.balanceOf(act[0]).call();\n  console.log(balance);\n  return {\n    balance: balance\n  };\n});\nexport const getTokenBalance = createAsyncThunk('Org/getTokenBalance', async () => {\n  let act = await web3.eth.getAccounts();\n  console.log(\"methods\", tcontroller.methods);\n  let balance = await tcontroller.methods.balanceOf(act[0]).call();\n  console.log(\"l balance is \", balance);\n  return {\n    balance: balance\n  };\n});\nexport const purchaseNormalSubscription = createAsyncThunk('Org/purchaseNormalSubscription', async data => {\n  let act = await web3.eth.getAccounts();\n  await controller.methods.buyNormalSubsciption(data.owner).send({\n    from: act[0]\n  });\n  let naccess = await controller.methods.doesUserHasNormalAccess(data.owner).call({\n    from: act[0]\n  });\n  let balance = await tcontroller.methods.balanceOf(act[0]).call();\n\n  if (naccess == true) {\n    naccess = 'Yes';\n  } else {\n    naccess = 'No';\n  }\n\n  return {\n    naccess: naccess,\n    balance: balance\n  };\n});\nexport const purchasePremiumSubscription = createAsyncThunk('Org/purchasePremiumSubscription', async data => {\n  let act = await web3.eth.getAccounts();\n  await controller.methods.buyPremiumSubscription(data.owner).send({\n    from: act[0]\n  });\n  let paccess = await controller.methods.doesUserHasPremiumAccess(data.owner).call({\n    from: act[0]\n  });\n  let balance = await tcontroller.methods.balanceOf(act[0]).call();\n\n  if (paccess == true) {\n    paccess = 'Yes';\n  } else {\n    paccess = 'No';\n  }\n\n  return {\n    paccess: paccess,\n    balance: balance\n  };\n});\n/*\nexport const loadSelectElements = createAsyncThunk('node/loadSelectElements', async () => {\n  const response = await controller.methods.nodeCount().call();\n  const options = [];\n  for(var i=0;i < response;i++){\n      options.push({ value: i, label: i })\n  }\n  return options;\n})\n\nexport const getBalanceAsync = createAsyncThunk('node/getBalanceAsync', async (_nodeId) => {\n  const response = await controller.methods.getCumulativeNodeDeposit(_nodeId).call();\n  return response;\n})\n\nexport const updateCurrentNodeAsync = createAsyncThunk('node/updateCurrentNodeAsync', async (_nodeId) => {\n  return parseInt(_nodeId);\n})\n\n\nexport const stakeRenAsync = createAsyncThunk('node/stakeRenAsync', async (data) => {\n  //const {_amount,_nodeId,_sender}= data;\n  await controller.methods.stakeRen(parseInt(data.incrementAmount),parseInt(data.currentNode)).send({from:data.user});\n\n  \n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(data.currentNode).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  \n\n  const share = await controller.methods.getMyCumulativeNodeDeposit(parseInt(data.currentNode)).call({from:data.user});\n\n  return {nodeId: data.currentNode, nodeBalance: nodeBalance, status: status, share:share}\n})\n\n\nexport const createNodeAsync = createAsyncThunk('node/createNodeAsync', async (_user) => {\n  const response = await controller.methods.createNode().send({from:_user});\n  return response;\n})\n\nexport const getNodeAsync = createAsyncThunk('node/getNodeAsync', async () => {\n  const response = await controller.methods.nodeCount().call();\n  return parseInt(response)-1;\n})\n\nexport const getDepositStatusAsync = createAsyncThunk('node/getDepositStatusAsync',async() => {\n  const currentNodeBalance = getBalanceAsync(getNodeAsync());\n  if(parseInt(currentNodeBalance) == 50000){\n    return 'full';\n  }\n  else{\n    return 'accepting';\n  }\n})\n\nexport const updateNodeStats = createAsyncThunk('node/updateNodeStats', async (data) => {\n  const response = await controller.methods.nodeCount().call();\n  \n  let nodeId \n  if(data._nodeId == -1){\n    nodeId= parseInt(response) - 1;\n  }\n  else{\n    nodeId = parseInt(data._nodeId)\n  }\n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(nodeId).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  const acts = await web3.eth.getAccounts();\n  console.log(\"user is\", acts[0])\n\n\n  const share = await controller.methods.getMyCumulativeNodeDeposit(nodeId).call({from:acts[0]});\n\n  return {nodeId: nodeId, nodeBalance: nodeBalance, status: status,share:share}\n})\n\n\n\nexport const isOwner = createAsyncThunk('node/isOwner', async (_user) => {\n  const response = await controller.methods.owner().call();\n  const acts = await web3.eth.getAccounts(); \n\n  if(response == acts[0]){\n    return 'yes';\n  }\n  else{\n    return 'no';\n  }\n  \n})\n\n*/\n\nlet initialState = {\n  currentOrg: '',\n  orgCreated: false,\n  normalSubFee: 0,\n  premiumSubFee: 0,\n  normalSubTime: 120,\n  premiumSubTime: 300,\n  userTokenBalance: 0,\n  doesUserHasNormalAccess: 'No',\n  doesUserHasPremiumAccess: 'No',\n  orgName: '',\n  orgOwner: '',\n  isOwner: false\n};\nconst OrgSlice = createSlice({\n  name: 'org',\n  initialState,\n  reducers: {// omit existing reducers here\n  },\n  extraReducers: builder => {\n    // Add reducers for additional action types here, and handle loading state as needed\n    builder.addCase(getCurrentOrg.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.currentOrg = action.payload.currentOrg;\n    }).addCase(registerAsOrganization.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.orgName = action.payload.name;\n      state.normalSubFee = action.payload.normalSubFee;\n      state.premiumSubFee = action.payload.premiumSubFee;\n      state.orgCreated = true;\n      state.userTokenBalance = action.payload.balance;\n      console.log(\"now owner is\", action.payload.owner);\n      state.orgOwner = action.payload.owner;\n      localStorage.setItem(\"owner\", action.payload.owner);\n      state.isOwner = true;\n      state.currentOrg = action.payload.owner;\n    }).addCase(getTokenBalance.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.userTokenBalance = action.payload.balance;\n    }).addCase(purchaseTokens.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.userTokenBalance = action.payload.balance;\n    }).addCase(updateStats.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.userTokenBalance = action.payload.balance;\n      state.currentOrg = action.payload.currentOrg;\n\n      if (localStorage.getItem(\"owner\") != action.payload.currentOrg) {\n        state.isOwner = false;\n      } else {\n        state.isOwner = true;\n      }\n\n      state.doesUserHasNormalAccess = action.payload.naccess;\n      console.log(\"user access\", action.payload.naccess);\n      state.doesUserHasPremiumAccess = action.payload.paccess;\n    }).addCase(purchaseNormalSubscription.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.userTokenBalance = action.payload.balance;\n      state.doesUserHasNormalAccess = action.payload.naccess;\n    }).addCase(purchasePremiumSubscription.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.userTokenBalance = action.payload.balance;\n      state.doesUserHasPremiumAccess = action.payload.paccess;\n    });\n    /*\n    .addCase(getBalanceAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded'\n      state.balance = action.payload\n    })\n    .addCase(getNodeAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded'\n      state.currentNode = action.payload\n    })\n    .addCase(getDepositStatusAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded'\n      state.depositStatus = action.payload\n    })\n    .addCase(updateNodeStats.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.depositStatus = action.payload.status\n      state.balance = action.payload.nodeBalance\n      state.currentNode = action.payload.nodeId\n      state.share = action.payload.share\n      state.status ='func'\n    })\n    .addCase(isOwner.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.owner = action.payload\n    })\n    .addCase(loadSelectElements.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.options = action.payload\n    })\n    .addCase(stakeRenAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.depositStatus = action.payload.status\n      state.balance = action.payload.nodeBalance\n      state.currentNode = action.payload.nodeId\n      state.share = action.payload.share\n      state.status ='func'\n    })\n    */\n  }\n});\nexport default OrgSlice.reducer;","map":{"version":3,"sources":["/home/kesha/Desktop/phase_4_50360333_CSE526/Phase_4_source_code/src/features/OrgUpdater/OrgSlice.js"],"names":["createSlice","nanoid","createAsyncThunk","web3","controller","tcontroller","store","getCurrentOrg","acts","eth","getAccounts","currentOrg","updateStats","data","act","balance","methods","balanceOf","call","naccess","doesUserHasNormalAccess","localStorage","getItem","from","paccess","doesUserHasPremiumAccess","registerAsOrganization","name","parseInt","normalSubFee","premiumSubFee","send","owner","purchaseTokens","value","console","log","getTokenBalance","purchaseNormalSubscription","buyNormalSubsciption","purchasePremiumSubscription","buyPremiumSubscription","initialState","orgCreated","normalSubTime","premiumSubTime","userTokenBalance","orgName","orgOwner","isOwner","OrgSlice","reducers","extraReducers","builder","addCase","fulfilled","state","action","payload","setItem","reducer"],"mappings":"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AAG,GAAG,MAAMX,IAAI,CAACM,GAAL,CAASC,WAAT,EAAhB;AACA,QAAMN,UAAU,CAACY,OAAX,CAAmByB,sBAAnB,CAA0C5B,IAAI,CAACmB,KAA/C,EAAsDD,IAAtD,CAA2D;AAACR,IAAAA,IAAI,EAACT,GAAG,CAAC,CAAD;AAAT,GAA3D,CAAN;AACA,MAAIU,OAAO,GAAG,MAAMpB,UAAU,CAACY,OAAX,CAAmBS,wBAAnB,CAA4CZ,IAAI,CAACmB,KAAjD,EAAwDd,IAAxD,CAA6D;AAACK,IAAAA,IAAI,EAACT,GAAG,CAAC,CAAD;AAAT,GAA7D,CAApB;AACA,MAAIC,OAAO,GAAG,MAAMV,WAAW,CAACW,OAAZ,CAAoBC,SAApB,CAA8BH,GAAG,CAAC,CAAD,CAAjC,EAAsCI,IAAtC,EAApB;;AACA,MAAGM,OAAO,IAAI,IAAd,EAAmB;AACfA,IAAAA,OAAO,GAAC,KAAR;AACH,GAFD,MAGI;AACAA,IAAAA,OAAO,GAAC,IAAR;AACH;;AACD,SAAO;AAAEA,IAAAA,OAAO,EAAGA,OAAZ;AAAqBT,IAAAA,OAAO,EAAEA;AAA9B,GAAP;AACP,CAZ0D,CAApD;AAkBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,IAAI2B,YAAY,GAAE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B;AAChE;AACAD,MAAAA,KAAK,CAACV,gBAAN,GAAyBW,MAAM,CAACC,OAAP,CAAe3C,OAAxC;AACAyC,MAAAA,KAAK,CAACpC,uBAAN,GAAgCqC,MAAM,CAACC,OAAP,CAAevC,OAA/C;AACD,KA5CD,EA6CCmC,OA7CD,CA6CSd,2BAA2B,CAACe,SA7CrC,EA6CgD,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACjE;AACAD,MAAAA,KAAK,CAACV,gBAAN,GAAyBW,MAAM,CAACC,OAAP,CAAe3C,OAAxC;AACAyC,MAAAA,KAAK,CAAC/B,wBAAN,GAAiCgC,MAAM,CAACC,OAAP,CAAelC,OAAhD;AACD,KAjDD;AAmDA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEK;AAtGwB,CAAD,CAA5B;AA0GE,eAAe0B,QAAQ,CAACU,OAAxB","sourcesContent":["import { createSlice, nanoid, createAsyncThunk } from '@reduxjs/toolkit'\n//import controller from '../controller'\nimport web3 from './../web3'\nimport {controller, tcontroller} from '../controller'\nimport {store} from '../../app/store'\n\n\n\n\n\nexport const getCurrentOrg = createAsyncThunk('Org/getCurrentOrg', async () => {\n  const acts = await web3.eth.getAccounts(); \n  return { currentOrg: acts[0]};\n})\n\nexport const updateStats = createAsyncThunk('Org/updateStats', async (data) => {\n\n     let act = await web3.eth.getAccounts();\n\n     let balance = await tcontroller.methods.balanceOf(act[0]).call();\n\n     \n     //let own = await store.getState().owner\n     //console.log(\"ownnene\", own)\n     let naccess = await controller.methods.doesUserHasNormalAccess(localStorage.getItem(\"owner\")).call({from:act[0]})\n     \n     let paccess = await controller.methods.doesUserHasPremiumAccess(localStorage.getItem(\"owner\")).call({from:act[0]})\n\n     if(naccess == true){\n       naccess='Yes'\n     }\n     else{\n      naccess='No'\n     }\n\n     if(paccess == true){\n       paccess='Yes'\n     }\n     else{\n      paccess='No'\n     }\n     return { currentOrg: act[0],balance : balance , paccess: paccess, naccess: naccess}\n\n\n})\n\n\nexport const registerAsOrganization = createAsyncThunk('Org/registerAsOrganizaton', async (data) => {\n     \n     let act = await web3.eth.getAccounts();\n\n     await controller.methods.registerAsOrganization(data.name,parseInt(data.normalSubFee), parseInt(data.premiumSubFee)).send({from:act[0]});\n     \n\n     return {premiumSubFee: data.premiumSubFee, normalSubFee: data.normalSubFee, name: data.name, owner : act[0]}\n})\n\n\nexport const purchaseTokens = createAsyncThunk('Org/purchaseTokens', async (data) => {\n     let act = await web3.eth.getAccounts();\n     await controller.methods.purchaseTokens().send({from:act[0], value: data.value});\n     let balance = await tcontroller.methods.balanceOf(act[0]).call();\n     console.log(balance);\n     return {balance:balance}\n})\n\nexport const getTokenBalance = createAsyncThunk('Org/getTokenBalance', async () => {\n     let act = await web3.eth.getAccounts();\n     console.log(\"methods\", tcontroller.methods)\n     let balance = await tcontroller.methods.balanceOf(act[0]).call();\n\n     console.log(\"l balance is \", balance)\n     return { balance : balance }\n})\n\nexport const purchaseNormalSubscription = createAsyncThunk('Org/purchaseNormalSubscription', async (data) => {\n        let act = await web3.eth.getAccounts();\n        await controller.methods.buyNormalSubsciption(data.owner).send({from:act[0] });\n        let naccess = await controller.methods.doesUserHasNormalAccess(data.owner).call({from:act[0]})\n        let balance = await tcontroller.methods.balanceOf(act[0]).call();\n         if(naccess == true){\n             naccess='Yes'\n         }\n         else{\n             naccess='No'\n         }\n        return { naccess : naccess, balance: balance }\n})\n\n\nexport const purchasePremiumSubscription = createAsyncThunk('Org/purchasePremiumSubscription', async (data) => {\n        let act = await web3.eth.getAccounts();\n        await controller.methods.buyPremiumSubscription(data.owner).send({from:act[0] });\n        let paccess = await controller.methods.doesUserHasPremiumAccess(data.owner).call({from:act[0]})\n        let balance = await tcontroller.methods.balanceOf(act[0]).call();\n        if(paccess == true){\n            paccess='Yes'\n        }\n        else{\n            paccess='No'\n        }\n        return { paccess : paccess, balance: balance }        \n})\n\n\n\n\n\n/*\nexport const loadSelectElements = createAsyncThunk('node/loadSelectElements', async () => {\n  const response = await controller.methods.nodeCount().call();\n  const options = [];\n  for(var i=0;i < response;i++){\n      options.push({ value: i, label: i })\n  }\n  return options;\n})\n\nexport const getBalanceAsync = createAsyncThunk('node/getBalanceAsync', async (_nodeId) => {\n  const response = await controller.methods.getCumulativeNodeDeposit(_nodeId).call();\n  return response;\n})\n\nexport const updateCurrentNodeAsync = createAsyncThunk('node/updateCurrentNodeAsync', async (_nodeId) => {\n  return parseInt(_nodeId);\n})\n\n\nexport const stakeRenAsync = createAsyncThunk('node/stakeRenAsync', async (data) => {\n  //const {_amount,_nodeId,_sender}= data;\n  await controller.methods.stakeRen(parseInt(data.incrementAmount),parseInt(data.currentNode)).send({from:data.user});\n\n  \n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(data.currentNode).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  \n\n  const share = await controller.methods.getMyCumulativeNodeDeposit(parseInt(data.currentNode)).call({from:data.user});\n\n  return {nodeId: data.currentNode, nodeBalance: nodeBalance, status: status, share:share}\n})\n\n\nexport const createNodeAsync = createAsyncThunk('node/createNodeAsync', async (_user) => {\n  const response = await controller.methods.createNode().send({from:_user});\n  return response;\n})\n\nexport const getNodeAsync = createAsyncThunk('node/getNodeAsync', async () => {\n  const response = await controller.methods.nodeCount().call();\n  return parseInt(response)-1;\n})\n\nexport const getDepositStatusAsync = createAsyncThunk('node/getDepositStatusAsync',async() => {\n  const currentNodeBalance = getBalanceAsync(getNodeAsync());\n  if(parseInt(currentNodeBalance) == 50000){\n    return 'full';\n  }\n  else{\n    return 'accepting';\n  }\n})\n\nexport const updateNodeStats = createAsyncThunk('node/updateNodeStats', async (data) => {\n  const response = await controller.methods.nodeCount().call();\n  \n  let nodeId \n  if(data._nodeId == -1){\n    nodeId= parseInt(response) - 1;\n  }\n  else{\n    nodeId = parseInt(data._nodeId)\n  }\n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(nodeId).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  const acts = await web3.eth.getAccounts();\n  console.log(\"user is\", acts[0])\n\n\n  const share = await controller.methods.getMyCumulativeNodeDeposit(nodeId).call({from:acts[0]});\n\n  return {nodeId: nodeId, nodeBalance: nodeBalance, status: status,share:share}\n})\n\n\n\nexport const isOwner = createAsyncThunk('node/isOwner', async (_user) => {\n  const response = await controller.methods.owner().call();\n  const acts = await web3.eth.getAccounts(); \n\n  if(response == acts[0]){\n    return 'yes';\n  }\n  else{\n    return 'no';\n  }\n  \n})\n\n*/\n\n\nlet initialState= {\n      currentOrg: '',\n      orgCreated: false,\n      normalSubFee:0,\n      premiumSubFee:0,\n      normalSubTime:120,\n      premiumSubTime:300,\n      userTokenBalance:0,\n      doesUserHasNormalAccess: 'No',\n      doesUserHasPremiumAccess: 'No',\n      orgName: '',\n      orgOwner:'',\n      isOwner:false\n    }\nconst OrgSlice = createSlice({\n    name:'org',\n    initialState,\n    \n    reducers: {\n      // omit existing reducers here\n    },\n    extraReducers: (builder) => {\n      // Add reducers for additional action types here, and handle loading state as needed\n      builder.addCase(getCurrentOrg.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.currentOrg = action.payload.currentOrg\n      })\n      .addCase(registerAsOrganization.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.orgName = action.payload.name\n        state.normalSubFee = action.payload.normalSubFee\n        state.premiumSubFee = action.payload.premiumSubFee\n        state.orgCreated = true\n        state.userTokenBalance = action.payload.balance\n        console.log(\"now owner is\", action.payload.owner)\n        state.orgOwner = action.payload.owner\n        localStorage.setItem(\"owner\", action.payload.owner)\n        state.isOwner = true\n        state.currentOrg = action.payload.owner\n      })\n      .addCase(getTokenBalance.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.userTokenBalance = action.payload.balance\n      })\n      .addCase(purchaseTokens.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.userTokenBalance = action.payload.balance\n      })\n      .addCase(updateStats.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.userTokenBalance = action.payload.balance\n        state.currentOrg = action.payload.currentOrg\n        if(localStorage.getItem(\"owner\") != action.payload.currentOrg){\n          state.isOwner= false\n        }\n        else{\n          state.isOwner=true\n        }\n        state.doesUserHasNormalAccess = action.payload.naccess\n        console.log(\"user access\", action.payload.naccess)\n        state.doesUserHasPremiumAccess = action.payload.paccess\n        \n      })\n      .addCase(purchaseNormalSubscription.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.userTokenBalance = action.payload.balance\n        state.doesUserHasNormalAccess = action.payload.naccess\n      })\n      .addCase(purchasePremiumSubscription.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.userTokenBalance = action.payload.balance\n        state.doesUserHasPremiumAccess = action.payload.paccess\n      })\n\n      /*\n      .addCase(getBalanceAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.balance = action.payload\n      })\n      .addCase(getNodeAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.currentNode = action.payload\n      })\n      .addCase(getDepositStatusAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.depositStatus = action.payload\n      })\n      .addCase(updateNodeStats.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.depositStatus = action.payload.status\n        state.balance = action.payload.nodeBalance\n        state.currentNode = action.payload.nodeId\n        state.share = action.payload.share\n        state.status ='func'\n      })\n      .addCase(isOwner.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.owner = action.payload\n      })\n      .addCase(loadSelectElements.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.options = action.payload\n      })\n      .addCase(stakeRenAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.depositStatus = action.payload.status\n        state.balance = action.payload.nodeBalance\n        state.currentNode = action.payload.nodeId\n        state.share = action.payload.share\n        state.status ='func'\n      })\n      */\n      \n    }\n})\n\n\n  export default OrgSlice.reducer"]},"metadata":{},"sourceType":"module"}