{"ast":null,"code":"import { createSlice, nanoid, createAsyncThunk } from '@reduxjs/toolkit';\nimport controller from '../controller';\nimport web3 from './../web3';\nexport const getCurrentOrg = createAsyncThunk('Org/getCurrentOrg', async () => {\n  const acts = await web3.eth.getAccounts();\n  return acts[0];\n});\nexport const registerAsOrganization = createAsyncThunk('org/registerAsOrg', async data => {\n  await controller.methods.registerAsOrganization(data.name, parseInt(data.normalSubFee), parseInt(data.premiumSubFee)).send({\n    from: data.user\n  });\n});\n/*\nexport const loadSelectElements = createAsyncThunk('node/loadSelectElements', async () => {\n  const response = await controller.methods.nodeCount().call();\n  const options = [];\n  for(var i=0;i < response;i++){\n      options.push({ value: i, label: i })\n  }\n  return options;\n})\n\nexport const getBalanceAsync = createAsyncThunk('node/getBalanceAsync', async (_nodeId) => {\n  const response = await controller.methods.getCumulativeNodeDeposit(_nodeId).call();\n  return response;\n})\n\nexport const updateCurrentNodeAsync = createAsyncThunk('node/updateCurrentNodeAsync', async (_nodeId) => {\n  return parseInt(_nodeId);\n})\n\n\nexport const stakeRenAsync = createAsyncThunk('node/stakeRenAsync', async (data) => {\n  //const {_amount,_nodeId,_sender}= data;\n  await controller.methods.stakeRen(parseInt(data.incrementAmount),parseInt(data.currentNode)).send({from:data.user});\n\n  \n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(data.currentNode).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  \n\n  const share = await controller.methods.getMyCumulativeNodeDeposit(parseInt(data.currentNode)).call({from:data.user});\n\n  return {nodeId: data.currentNode, nodeBalance: nodeBalance, status: status, share:share}\n})\n\n\nexport const createNodeAsync = createAsyncThunk('node/createNodeAsync', async (_user) => {\n  const response = await controller.methods.createNode().send({from:_user});\n  return response;\n})\n\nexport const getNodeAsync = createAsyncThunk('node/getNodeAsync', async () => {\n  const response = await controller.methods.nodeCount().call();\n  return parseInt(response)-1;\n})\n\nexport const getDepositStatusAsync = createAsyncThunk('node/getDepositStatusAsync',async() => {\n  const currentNodeBalance = getBalanceAsync(getNodeAsync());\n  if(parseInt(currentNodeBalance) == 50000){\n    return 'full';\n  }\n  else{\n    return 'accepting';\n  }\n})\n\nexport const updateNodeStats = createAsyncThunk('node/updateNodeStats', async (data) => {\n  const response = await controller.methods.nodeCount().call();\n  \n  let nodeId \n  if(data._nodeId == -1){\n    nodeId= parseInt(response) - 1;\n  }\n  else{\n    nodeId = parseInt(data._nodeId)\n  }\n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(nodeId).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  const acts = await web3.eth.getAccounts();\n  console.log(\"user is\", acts[0])\n\n\n  const share = await controller.methods.getMyCumulativeNodeDeposit(nodeId).call({from:acts[0]});\n\n  return {nodeId: nodeId, nodeBalance: nodeBalance, status: status,share:share}\n})\n\n\n\nexport const isOwner = createAsyncThunk('node/isOwner', async (_user) => {\n  const response = await controller.methods.owner().call();\n  const acts = await web3.eth.getAccounts(); \n\n  if(response == acts[0]){\n    return 'yes';\n  }\n  else{\n    return 'no';\n  }\n  \n})\n\n*/\n\nlet initialState = {\n  currentOrg: '',\n  orgCreated: false\n};\nconst OrgSlice = createSlice({\n  name: 'org',\n  initialState,\n  reducers: {// omit existing reducers here\n  },\n  extraReducers: builder => {\n    // Add reducers for additional action types here, and handle loading state as needed\n    builder.addCase(getCurrentOrg.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded';\n      state.currentOrg = action.payload;\n    });\n    /*\n    .addCase(getBalanceAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded'\n      state.balance = action.payload\n    })\n    .addCase(getNodeAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded'\n      state.currentNode = action.payload\n    })\n    .addCase(getDepositStatusAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.status = 'succeeded'\n      state.depositStatus = action.payload\n    })\n    .addCase(updateNodeStats.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.depositStatus = action.payload.status\n      state.balance = action.payload.nodeBalance\n      state.currentNode = action.payload.nodeId\n      state.share = action.payload.share\n      state.status ='func'\n    })\n    .addCase(isOwner.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.owner = action.payload\n    })\n    .addCase(loadSelectElements.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.options = action.payload\n    })\n    .addCase(stakeRenAsync.fulfilled, (state, action) => {\n      // Add user to the state array\n      state.depositStatus = action.payload.status\n      state.balance = action.payload.nodeBalance\n      state.currentNode = action.payload.nodeId\n      state.share = action.payload.share\n      state.status ='func'\n    })\n    */\n  }\n});\nexport default OrgSlice.reducer;","map":{"version":3,"sources":["/home/kesha/Videos/Summer2021-main/REN_UI/src/features/OrgUpdater/OrgSlice.js"],"names":["createSlice","nanoid","createAsyncThunk","controller","web3","getCurrentOrg","acts","eth","getAccounts","registerAsOrganization","data","methods","name","parseInt","normalSubFee","premiumSubFee","send","from","user","initialState","currentOrg","orgCreated","OrgSlice","reducers","extraReducers","builder","addCase","fulfilled","state","action","status","payload","reducer"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,MAAtB,EAA8BC,gBAA9B,QAAsD,kBAAtD;AACA,OAAOC,UAAP,MAAuB,eAAvB;AACA,OAAOC,IAAP,MAAiB,WAAjB;AAMA,OAAO,MAAMC,aAAa,GAAGH,gBAAgB,CAAC,mBAAD,EAAsB,YAAY;AAC7E,QAAMI,IAAI,GAAG,MAAMF,IAAI,CAACG,GAAL,CAASC,WAAT,EAAnB;AACA,SAAOF,IAAI,CAAC,CAAD,CAAX;AACD,CAH4C,CAAtC;AAMP,OAAO,MAAMG,sBAAsB,GAAGP,gBAAgB,CAAC,mBAAD,EAAsB,MAAOQ,IAAP,IAAgB;AACvF,QAAMP,UAAU,CAACQ,OAAX,CAAmBF,sBAAnB,CAA0CC,IAAI,CAACE,IAA/C,EAAoDC,QAAQ,CAACH,IAAI,CAACI,YAAN,CAA5D,EAAiFD,QAAQ,CAACH,IAAI,CAACK,aAAN,CAAzF,EAA+GC,IAA/G,CAAoH;AAACC,IAAAA,IAAI,EAACP,IAAI,CAACQ;AAAX,GAApH,CAAN;AACJ,CAFqD,CAA/C;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,IAAIC,YAAY,GAAE;AACZC,EAAAA,UAAU,EAAE,EADA;AAEZC,EAAAA,UAAU,EAAE;AAFA,CAAlB;AAIA,MAAMC,QAAQ,GAAGtB,WAAW,CAAC;AACzBY,EAAAA,IAAI,EAAE,KADmB;AAEzBO,EAAAA,YAFyB;AAGzBI,EAAAA,QAAQ,EAAE,CACR;AADQ,GAHe;AAMzBC,EAAAA,aAAa,EAAGC,OAAD,IAAa;AAC1B;AACAA,IAAAA,OAAO,CAACC,OAAR,CAAgBrB,aAAa,CAACsB,SAA9B,EAAyC,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC1D;AACAD,MAAAA,KAAK,CAACE,MAAN,GAAe,WAAf;AACAF,MAAAA,KAAK,CAACR,UAAN,GAAmBS,MAAM,CAACE,OAA1B;AACD,KAJD;AAKA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEK;AAvDwB,CAAD,CAA5B;AA2DE,eAAeT,QAAQ,CAACU,OAAxB","sourcesContent":["import { createSlice, nanoid, createAsyncThunk } from '@reduxjs/toolkit'\nimport controller from '../controller'\nimport web3 from './../web3'\n\n\n\n\n\nexport const getCurrentOrg = createAsyncThunk('Org/getCurrentOrg', async () => {\n  const acts = await web3.eth.getAccounts(); \n  return acts[0];\n})\n\n\nexport const registerAsOrganization = createAsyncThunk('org/registerAsOrg', async (data) => {\n     await controller.methods.registerAsOrganization(data.name,parseInt(data.normalSubFee), parseInt(data.premiumSubFee)).send({from:data.user});\n})\n/*\nexport const loadSelectElements = createAsyncThunk('node/loadSelectElements', async () => {\n  const response = await controller.methods.nodeCount().call();\n  const options = [];\n  for(var i=0;i < response;i++){\n      options.push({ value: i, label: i })\n  }\n  return options;\n})\n\nexport const getBalanceAsync = createAsyncThunk('node/getBalanceAsync', async (_nodeId) => {\n  const response = await controller.methods.getCumulativeNodeDeposit(_nodeId).call();\n  return response;\n})\n\nexport const updateCurrentNodeAsync = createAsyncThunk('node/updateCurrentNodeAsync', async (_nodeId) => {\n  return parseInt(_nodeId);\n})\n\n\nexport const stakeRenAsync = createAsyncThunk('node/stakeRenAsync', async (data) => {\n  //const {_amount,_nodeId,_sender}= data;\n  await controller.methods.stakeRen(parseInt(data.incrementAmount),parseInt(data.currentNode)).send({from:data.user});\n\n  \n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(data.currentNode).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  \n\n  const share = await controller.methods.getMyCumulativeNodeDeposit(parseInt(data.currentNode)).call({from:data.user});\n\n  return {nodeId: data.currentNode, nodeBalance: nodeBalance, status: status, share:share}\n})\n\n\nexport const createNodeAsync = createAsyncThunk('node/createNodeAsync', async (_user) => {\n  const response = await controller.methods.createNode().send({from:_user});\n  return response;\n})\n\nexport const getNodeAsync = createAsyncThunk('node/getNodeAsync', async () => {\n  const response = await controller.methods.nodeCount().call();\n  return parseInt(response)-1;\n})\n\nexport const getDepositStatusAsync = createAsyncThunk('node/getDepositStatusAsync',async() => {\n  const currentNodeBalance = getBalanceAsync(getNodeAsync());\n  if(parseInt(currentNodeBalance) == 50000){\n    return 'full';\n  }\n  else{\n    return 'accepting';\n  }\n})\n\nexport const updateNodeStats = createAsyncThunk('node/updateNodeStats', async (data) => {\n  const response = await controller.methods.nodeCount().call();\n  \n  let nodeId \n  if(data._nodeId == -1){\n    nodeId= parseInt(response) - 1;\n  }\n  else{\n    nodeId = parseInt(data._nodeId)\n  }\n  const nodeBalance = await controller.methods.getCumulativeNodeDeposit(nodeId).call();\n  let status\n  if(parseInt(nodeBalance) == 50000){\n    status = 'full';\n  }\n  else{\n    status = 'accepting';\n  }\n\n  const acts = await web3.eth.getAccounts();\n  console.log(\"user is\", acts[0])\n\n\n  const share = await controller.methods.getMyCumulativeNodeDeposit(nodeId).call({from:acts[0]});\n\n  return {nodeId: nodeId, nodeBalance: nodeBalance, status: status,share:share}\n})\n\n\n\nexport const isOwner = createAsyncThunk('node/isOwner', async (_user) => {\n  const response = await controller.methods.owner().call();\n  const acts = await web3.eth.getAccounts(); \n\n  if(response == acts[0]){\n    return 'yes';\n  }\n  else{\n    return 'no';\n  }\n  \n})\n\n*/\n\n\nlet initialState= {\n      currentOrg: '',\n      orgCreated: false\n    }\nconst OrgSlice = createSlice({\n    name: 'org',\n    initialState,\n    reducers: {\n      // omit existing reducers here\n    },\n    extraReducers: (builder) => {\n      // Add reducers for additional action types here, and handle loading state as needed\n      builder.addCase(getCurrentOrg.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.currentOrg = action.payload\n      })\n      /*\n      .addCase(getBalanceAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.balance = action.payload\n      })\n      .addCase(getNodeAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.currentNode = action.payload\n      })\n      .addCase(getDepositStatusAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.status = 'succeeded'\n        state.depositStatus = action.payload\n      })\n      .addCase(updateNodeStats.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.depositStatus = action.payload.status\n        state.balance = action.payload.nodeBalance\n        state.currentNode = action.payload.nodeId\n        state.share = action.payload.share\n        state.status ='func'\n      })\n      .addCase(isOwner.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.owner = action.payload\n      })\n      .addCase(loadSelectElements.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.options = action.payload\n      })\n      .addCase(stakeRenAsync.fulfilled, (state, action) => {\n        // Add user to the state array\n        state.depositStatus = action.payload.status\n        state.balance = action.payload.nodeBalance\n        state.currentNode = action.payload.nodeId\n        state.share = action.payload.share\n        state.status ='func'\n      })\n      */\n      \n    }\n})\n\n\n  export default OrgSlice.reducer"]},"metadata":{},"sourceType":"module"}